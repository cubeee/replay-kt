/**
 * Artistic License 2.0
 * Copyright (c) 2000-2006, The Perl Foundation.
 *
 * Everyone is permitted to copy and distribute verbatim copies of this license
 * document, but changing it is not allowed.
 *
 * Preamble
 * This license establishes the terms under which a given free software Package may
 * be copied, modified, distributed, and/or redistributed. The intent is that the
 * Copyright Holder maintains some artistic control over the development of that
 * Package while still keeping the Package available as open source and free
 * software.
 *
 * You are always permitted to make arrangements wholly outside of this license
 * directly with the Copyright Holder of a given Package. If the terms of this
 * license do not permit the full use that you propose to make of the Package, you
 * should contact the Copyright Holder and seek a different licensing arrangement.
 *
 * Definitions
 * "Copyright Holder" means the individual(s) or organization(s) named in the
 * copyright notice for the entire Package.
 *
 * "Contributor" means any party that has contributed code or other material to the
 * Package, in accordance with the Copyright Holder's procedures.
 *
 * "You" and "your" means any person who would like to copy, distribute, or modify
 * the Package.
 *
 * "Package" means the collection of files distributed by the Copyright Holder, and
 * derivatives of that collection and/or of those files. A given Package may
 * consist of either the Standard Version, or a Modified Version.
 *
 * "Distribute" means providing a copy of the Package or making it accessible to
 * anyone else, or in the case of a company or organization, to others outside of
 * your company or organization.
 *
 * "Distributor Fee" means any fee that you charge for Distributing this Package or
 * providing support for this Package to another party. It does not mean licensing
 * fees.
 *
 * "Standard Version" refers to the Package if it has not been modified, or has
 * been modified only in ways explicitly requested by the Copyright Holder.
 *
 * "Modified Version" means the Package, if it has been changed, and such changes
 * were not explicitly requested by the Copyright Holder.
 *
 * "Original License" means this Artistic License as Distributed with the Standard
 * Version of the Package, in its current version or as it may be modified by The
 * Perl Foundation in the future.
 *
 * "Source" form means the source code, documentation source, and configuration
 * files for the Package.
 *
 * "Compiled" form means the compiled bytecode, object code, binary, or any other
 * form resulting from mechanical transformation or translation of the Source form.
 *
 * Permission for Use and Modification Without Distribution
 * (1) You are permitted to use the Standard Version and create and use Modified
 * Versions for any purpose without restriction, provided that you do not
 * Distribute the Modified Version.
 *
 * Permissions for Redistribution of the Standard Version
 * (2) You may Distribute verbatim copies of the Source form of the Standard
 * Version of this Package in any medium without restriction, either gratis or for
 * a Distributor Fee, provided that you duplicate all of the original copyright
 * notices and associated disclaimers. At your discretion, such verbatim copies may
 * or may not include a Compiled form of the Package.
 *
 * (3) You may apply any bug fixes, portability changes, and other modifications
 * made available from the Copyright Holder. The resulting Package will still be
 * considered the Standard Version, and as such will be subject to the Original
 * License.
 *
 * Distribution of Modified Versions of the Package as Source
 * (4) You may Distribute your Modified Version as Source (either gratis or for a
 * Distributor Fee, and with or without a Compiled form of the Modified Version)
 * provided that you clearly document how it differs from the Standard Version,
 * including, but not limited to, documenting any non-standard features,
 * executables, or modules, and provided that you do at least ONE of the following:
 *
 * (a) make the Modified Version available to the Copyright Holder of the Standard
 * Version, under the Original License, so that the Copyright Holder may include
 * your modifications in the Standard Version.
 * (b) ensure that installation of your Modified Version does not prevent the user
 * installing or running the Standard Version. In addition, the Modified Version
 * must bear a name that is different from the name of the Standard Version.
 * (c) allow anyone who receives a copy of the Modified Version to make the Source
 * form of the Modified Version available to others under
 * (i) the Original License or
 * (ii) a license that permits the licensee to freely copy, modify and redistribute
 * the Modified Version using the same licensing terms that apply to the copy that
 * the licensee received, and requires that the Source form of the Modified
 * Version, and of any works derived from it, be made freely available in that
 * license fees are prohibited but Distributor Fees are allowed.
 *
 * Distribution of Compiled Forms of the Standard Version or Modified Versions
 * without the Source
 * (5) You may Distribute Compiled forms of the Standard Version without the
 * Source, provided that you include complete instructions on how to get the Source
 * of the Standard Version. Such instructions must be valid at the time of your
 * distribution. If these instructions, at any time while you are carrying out such
 * distribution, become invalid, you must provide new instructions on demand or
 * cease further distribution. If you provide valid instructions or cease
 * distribution within thirty days after you become aware that the instructions are
 * invalid, then you do not forfeit any of your rights under this license.
 *
 * (6) You may Distribute a Modified Version in Compiled form without the Source,
 * provided that you comply with Section 4 with respect to the Source of the
 * Modified Version.
 *
 * Aggregating or Linking the Package
 * (7) You may aggregate the Package (either the Standard Version or Modified
 * Version) with other packages and Distribute the resulting aggregation provided
 * that you do not charge a licensing fee for the Package. Distributor Fees are
 * permitted, and licensing fees for other components in the aggregation are
 * permitted. The terms of this license apply to the use and Distribution of the
 * Standard or Modified Versions as included in the aggregation.
 *
 * (8) You are permitted to link Modified and Standard Versions with other works,
 * to embed the Package in a larger work of your own, or to build stand-alone
 * binary or bytecode versions of applications that include the Package, and
 * Distribute the result without restriction, provided the result does not expose a
 * direct interface to the Package.
 *
 * Items That are Not Considered Part of a Modified Version
 *
 * (9) Works (including, but not limited to, modules and scripts) that merely
 * extend or make use of the Package, do not, by themselves, cause the Package to
 * be a Modified Version. In addition, such works are not considered parts of the
 * Package itself, and are not subject to the terms of this license.
 *
 * General Provisions
 *
 * (10) Any use, modification, and distribution of the Standard or Modified
 * Versions is governed by this Artistic License. By using, modifying or
 * distributing the Package, you accept this license. Do not use, modify, or
 * distribute the Package, if you do not accept this license.
 *
 * (11) If your Modified Version has been derived from a Modified Version made by
 * someone other than you, you are nevertheless required to ensure that your
 * Modified Version complies with the requirements of this license.
 *
 * (12) This license does not grant you the right to use any trademark, service
 * mark, tradename, or logo of the Copyright Holder.
 *
 * (13) This license includes the non-exclusive, worldwide, free-of-charge patent
 * license to make, have made, use, offer to sell, sell, import and otherwise
 * transfer the Package with respect to any patent claims licensable by the
 * Copyright Holder that are necessarily infringed by the Package. If you institute
 * patent litigation (including a cross-claim or counterclaim) against any party
 * alleging that the Package constitutes direct or contributory patent
 * infringement, then this Artistic License to you shall terminate on the date that
 * such litigation is filed.
 *
 * (14) Disclaimer of Warranty: THE PACKAGE IS PROVIDED BY THE COPYRIGHT HOLDER AND
 * CONTRIBUTORS "AS IS' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES. THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR
 * NON-INFRINGEMENT ARE DISCLAIMED TO THE EXTENT PERMITTED BY YOUR LOCAL LAW.
 * UNLESS REQUIRED BY LAW, NO COPYRIGHT HOLDER OR CONTRIBUTOR WILL BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING IN ANY WAY
 * OUT OF THE USE OF THE PACKAGE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */
package com.x7ff.parser.buffer

import java.io.ByteArrayOutputStream
import java.math.BigInteger
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.charset.Charset

/**
 * BitBuffer written by TimePath for https://github.com/TimePath/commons.
 *
 * Original source code formatted with newer code style.
 *
 * @see <a target="_top" href="https://github.com/TimePath/commons/blob/master/src/main/kotlin/com/timepath/io/BitBuffer.kt">Source</a>
 */
class BitBuffer(
    /** The source of data */
    private val source: ByteBuffer
) {
    constructor(buffer: ByteArray) : this(ByteBuffer.wrap(buffer))

    /**
     * Total number of limit
     */
    private val capacityBits: Int = source.capacity() * 8

    /**
     * Position in limit
     */
    private var position: Int = 0

    /**
     * @return the capacity in bytes
     */
    fun capacity(): Int = capacityBits / 8

    fun get(dst: ByteArray): Unit = get(dst, 0, dst.size)

    fun get(dst: ByteArray, offset: Int, length: Int) {
        for (i in offset until (offset + length)) {
            dst[i] = getByte()
        }
    }

    fun get(length: Int) = BitBuffer(getBytes(length))

    fun get(offset: Int, length: Int): BitBuffer {
        val buffer = ByteArray(length)
        get(buffer, offset, length)
        return BitBuffer(buffer)
    }

    /** Copy of current byte in the source buffer */
    private var current: Byte = 0
    private var currentPos: Int = 0
    private operator fun next() {
        current = source.get()
        currentPos = position / 8
    }

    @Suppress("NOTHING_TO_INLINE")
    private inline operator fun Byte.get(n: Int) = toInt() and (1 shl n) != 0

    @Suppress("NOTHING_TO_INLINE")
    private inline operator fun Long.get(n: Int) = this and (1L shl n) != 0L

    @Suppress("NOTHING_TO_INLINE")
    private inline fun Byte.withBit(n: Int, b: Boolean) = when {
        b -> (toInt() or (1 shl n)).toByte()
        else -> (toInt() and (1 shl n).inv()).toByte()
    }

    @Suppress("NOTHING_TO_INLINE")
    private inline fun Long.withBit(n: Int, b: Boolean) = when {
        b -> (this or (1L shl n))
        else -> (this and (1L shl n).inv())
    }

    fun getBits(n: Int): Long {
        if (n == 0) return 0
        var data = 0L
        repeat(n) {
            val i = position++ % 8 // Bit offset in current byte
            if (i == 0) next() // Fill byte on boundary read
            data = data.withBit(it, current[i])
        }
        return data
    }

    fun getBitsMax(maxValue: Int): Long {
        val maxBits = Math.floor(Math.log10(maxValue.toDouble()) / Math.log10(2.0)) + 1

        var value = 0
        var i = 0
        while (i < maxBits && value + (1 shl i) < maxValue) {
            value += (if (getBoolean()) 1 else 0) shl i
            ++i
        }
        return value.toLong()
    }

    fun getIntFromBits(numBits: Int): Int {
        if (numBits <= 0 || numBits > 32) {
            throw IllegalArgumentException("Number of bits has to be more than zero and at most 32")
        }
        var result = 0
        for (i in 0 until numBits) {
            result += (if (getBoolean()) 1 else 0) shl i
        }
        return result
    }

    // TODO: optimize!
    fun getBytes(length: Int): ByteArray {
        val bytes = ByteArray(length)
        for (i in 0 until length) {
            bytes[i] = getByte()
        }
        return bytes
    }

    fun getBoolean(): Boolean = getBits(1) != 0L

    fun getByte(): Byte = getBits(8).toByte()
    fun getUByte(): Int = getByte().toUnsigned()

    fun getShort(): Short = getBits(16).toShort()
    fun getUShort(): Int = getShort().toUnsigned()

    fun getInt(): Int = getBits(32).toInt()
    fun getUInt(): Long = getInt().toUnsigned()
    fun getUInt(bits: Int): Long = getBits(bits).toInt().toUnsigned()

    fun getIntMax(max: Int): Int = getBitsMax(max).toInt()
    fun getUIntMax(max: Int): Long = getIntMax(max).toUnsigned()
    fun getUIntFromBits(numBits: Int): Long = getIntFromBits(numBits).toUnsigned()
    fun getInt64(): Long = getUInt() + (getUInt() shl 32)

    fun getFloat(): Float = java.lang.Float.intBitsToFloat(getInt())

    fun getLong(): Long = getBits(64)
    fun getULong(): BigInteger = getLong().toUnsigned()

    fun getDouble(): Double = java.lang.Double.longBitsToDouble(getLong())

    /**
     * @param limit never read more than this many bytes. If -1, up to the first terminating null byte ('\0')
     * @param exact always read to the limit
     */
    fun getStringBytes(limit: Int = -1, exact: Boolean = false): ByteArray {
        val baos = ByteArrayOutputStream()
        while (baos.size() != limit) {
            val c = getByte().toInt()
            if (c == 0) break
            baos.write(c)
        }
        if (exact && limit > 0) get(ByteArray(limit - baos.size())) // Read and discard the remainder
        return baos.toByteArray()
    }

    fun getFixedLengthString(): String {
        val strLength = getInt()

        val win1252StringConverter: ((ByteArray, Int) -> String)
                = { bytes, len -> String(bytes, 0, len - 1, Charset.forName("Windows-1252")) }
        val cp1250StringConverter: ((ByteArray, Int) -> String)
                = { bytes, len -> String(bytes, 0, len - 2, Charset.forName("CP1250")) }

        val (length, converter) = when {
            strLength < 0 -> Pair(strLength * -2, cp1250StringConverter)
            else -> Pair(strLength, win1252StringConverter)
        }

        val bytes = getBytes(length)

        return converter(bytes, length)
    }

    /**
     * @return true if more than 1 byte is available
     */
    fun hasRemaining(): Boolean = remaining() > 0

    /**
     * @return the number of remaining bytes
     */
    fun remaining(): Int = remainingBits() / 8

    /**
     * @return the number of remaining limit
     */
    fun remainingBits(): Int = capacityBits - position

    /**
     * @return true if more than 1 bit is available
     */
    fun hasRemainingBits(): Boolean = remainingBits() > 0

    /**
     * @return the limit in bytes
     */
    fun limit(): Int = capacityBits / 8

    /**
     * Does nothing.
     */
    fun order(@Suppress("UNUSED_PARAMETER") bo: ByteOrder): Unit = Unit

    /**
     * Sets the position.
     *
     * @param newPosition the new position
     */
    fun position(newPosition: Int): Unit = position(newPosition, 0)

    /**
     * Sets the position.
     *
     * @param newPosition the byte offset
     * @param bits        the bit offset
     */
    fun position(newPosition: Int, bits: Int) {
        source.position(newPosition)
        position = newPosition * 8 // Set byte position
        getBits(bits) // Read extra limit manually
    }

    fun positionBits(newPosition: Int) {
        source.position(newPosition / 8)
        position = newPosition
    }

    /**
     * @return the position in bytes
     */
    fun position(): Int = position / 8

    /**
     * @return the position in limit
     */
    fun positionBits(): Int = position
}

fun Byte.toUnsigned(): Int = this.toInt() and 0xff

fun Short.toUnsigned(): Int = this.toInt() and 0xffff

fun Int.toUnsigned(): Long = this.toLong() and 0xffffffffL

fun Long.toUnsigned(): BigInteger {
    val quot = (this ushr 1) / 5
    val rem = this - quot * 10
    return BigInteger(quot.toString() + rem)
}